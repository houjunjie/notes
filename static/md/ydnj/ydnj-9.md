### 第九章 生成器
在之前我们了解了Promise 如何把回调的控制反转过来，恢复了可信任性和可组合性。

现在我们把注意力转移到一种顺序。看似同步的异步流程控制表达风格。使这种风格成为可能的“魔法”就是 es6 生成器。

在es6代码中指示暂停点的语法是`yield`，我们来看下如下代码：
```
var x = 1;
function *foo() {
  x++;
  yield; //暂停
  console.log("x:", x)
}
function bar() {
  x++;
}
```
这是`*`号是生成器的标识，在函数名前面加`*`说明要新建一个生成器的函数，我们来运行一下前面的代码片段，使得bar()在*foo()内部的yield 处执行
```
// 构造一个迭代器it来控制这个生成器
var it = foo();
// 这里启动foo();
it.next();
x; // 2
bar();
x; // 3
it.next(); //x: 3
```
我们看下运算过程：
- it = foo() 运算并没有执行生成器 *foo(),而只是构造了一个迭代器，这个迭代器会控制它的执行。
- 第一个it.next() 启动了生成器 *foo(), 并运行了 *foo()第一行的 x++；
- *foo() 在 yield 语句处暂停,在这一点上第一个 it.next() 调用结束。此时 *foo() 仍在运行并且是活跃的,但处于暂停状态。
- 我们查看x的值，此时为2.
- 我们调用bar()，它通过x++再次递增x。
- 最后的 it.next() 调用从暂停处恢复了生成器 *foo() 的执行,并运行 console.log(..)语句,这条语句使用当前 x 的值 3。

**输入和输出**

生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但它仍然是一个函数，所以它仍然有函数的基本特性，比如接受参数（即输入），也能够返回值（即输出）

例如：
```
function *foo(x, y) {
  return x * y;
}
var it = foo(6, 7);
var res = it.next();
res.value; //42
```
