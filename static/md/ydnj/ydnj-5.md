### 第五章 语法

**语句与表达式**

在英语中：

“句子”是完整表达某个意思的一组词，由一个或多个“短语”组成，它们之间由标点符号或连接词（and和or等）连接起来。短语可以由更小的短语组成。有些短语是不完整的，不能独立表达意思；有些短语则相对完整，并且能够独立表达某个意思。这些规则就是英语的语法。

在JavaScript中也是如此。语句相当于句子，表达式相当于短语，运算符相当于标点符号和连接词

JavaScript中表达式可以返回一个结果值。例如
```
var a = 3 * 6;
var b = a;
b;
```
这里，3 * 6是一个表达式（结果为18）。第二行的a也是一个表达式，第三行的b也是。表达式a和b的结果值都是18；

这三行代码都是包含表达式的语句，var a = 3 * 6和 var b = a 称为“声明语句”。因为他们声明了变量（还可以为其赋值）。a = 3 * 6和b = a（不带var）叫做“赋值表达式”

第三行代码中只有一个表达式 b,同时它也是一个语句(虽然没有太大意义)。这样的情况通常叫作“表达式语句”


`语句都有一个结果值`（undefined也算）

以赋值表达式 b = a为例，其结果值是赋给b的值（18），但规范定义var的结果值是undefined。如果在控制台中输入var a = 42 会得到结果值undefined，而非42

ES5 规范 12.2 节中的变量声明 (VariableDeclaration)算法实际上有一个返回值(是一个包含所声明变量名称的字符串,很奇特吧?),但是这个值被变量语句(VariableStatement) 算法屏蔽掉了(for..in 循环除外),最后返回结果为空(undefined)。


**表达式的副作用**

大部分的表达式没有副作用。例如：
```
var a = 2;
var b = a + 3;
```
表达式a + 3本身没有副作用（比如改变a的值）。它的结果值为5，通过b = a + 3 赋值给变量b

最常见的有副作用（也可能没有）的表达式是函数调用
```
function foo() {
  a = a + 1
}
var a = 1;
foo();//结果值：undefined。副作用：a的值被改变
```
其他一些表达式也有副作用，比如：
```
var a = 42;
var b = a++;
a;//43
b;//42
```
a++首先返回变量a的当前值42（再将该值赋给b）。然后将a的值+1；

++ 在前面时,如 ++a,它的副作用(将 a 递增)产生在表达式返回结果值之前,而 a++ 的 副作用则产生在之后。

多个赋值语句串联时(链式赋值),赋值表达式(和语句)的结果值就 能派上用场,比如:

```
var a, b, c;
a = b = c = 42
```

这里c = 42的结果值为42(副作用是将c赋值42),然后b = 42的结果值为42(副作用 是将 b 赋值 42),最后是 a = 42(副作用是将 a 赋值 42)。

链式赋值常常被误用,例如var a = b = 42,看似和前面的例子差不多,实 则不然。如果变量b没有在作用域中象var b这样声明过,则var a = b = 42 不会对变量 b 进行声明。在严格模式中这样会产生错误,或者会无意中 创建一个全局变量

**代码块**

有一个坑常被提到（涉及强制类型转换）

```
[] + {}; //"[object Object]"
{} + []; // 0
```

表面上看 + 运算符根据第一个操作数([] 或 {})的不同会产生不同的结果,实则不然。

第一行代码中,{} 出现在 + 运算符表达式中,因此它被当作一个值(空对象)来处理。第
4 章讲过 [] 会被强制类型转换为 "",而 {} 会被强制类型转换为 "[object Object]"。

但在第二行代码中,{} 被当作一个独立的空代码块(不执行任何操作)。代码块结尾不需 要分号,所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为0。


**短路**
对 && 和 || 来说,如果从左边的操作数能够得出结果,就可以忽略右边的操作数。我们将 这种现象称为“短路”(即执行最短路径)。

以a && b为例,如果a是一个假值,足以决定&&的结果,就没有必要再判断b的值。同 样对于 a || b,如果 a 是一个真值,也足以决定 || 的结果,也就没有必要再判断 b 的值
